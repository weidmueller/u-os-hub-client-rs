// SPDX-FileCopyrightText: 2025 Weidmueller Interface GmbH & Co. KG <oss@weidmueller.com>
//
// SPDX-License-Identifier: MIT

// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum VariableOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A variable associated with the provider's definition.
pub struct Variable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Variable<'a> {
  type Inner = Variable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Variable<'a> {
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
  pub const VT_QUALITY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Variable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VariableArgs<'args>
  ) -> flatbuffers::WIPOffset<Variable<'bldr>> {
    let mut builder = VariableBuilder::new(_fbb);
    if let Some(x) = args.timestamp { builder.add_timestamp(x); }
    builder.add_id(args.id);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_quality(args.quality);
    builder.add_value_type(args.value_type);
    builder.finish()
  }

  pub fn unpack(&self) -> VariableT {
    let value = match self.value_type() {
      VariableValue::NONE => VariableValueT::NONE,
      VariableValue::Boolean => VariableValueT::Boolean(Box::new(
        self.value_as_boolean()
            .expect("Invalid union table, expected `VariableValue::Boolean`.")
            .unpack()
      )),
      VariableValue::Duration => VariableValueT::Duration(Box::new(
        self.value_as_duration()
            .expect("Invalid union table, expected `VariableValue::Duration`.")
            .unpack()
      )),
      VariableValue::Float64 => VariableValueT::Float64(Box::new(
        self.value_as_float_64()
            .expect("Invalid union table, expected `VariableValue::Float64`.")
            .unpack()
      )),
      VariableValue::Int64 => VariableValueT::Int64(Box::new(
        self.value_as_int_64()
            .expect("Invalid union table, expected `VariableValue::Int64`.")
            .unpack()
      )),
      VariableValue::String => VariableValueT::String(Box::new(
        self.value_as_string()
            .expect("Invalid union table, expected `VariableValue::String`.")
            .unpack()
      )),
      VariableValue::Timestamp => VariableValueT::Timestamp(Box::new(
        self.value_as_timestamp()
            .expect("Invalid union table, expected `VariableValue::Timestamp`.")
            .unpack()
      )),
      _ => VariableValueT::NONE,
    };
    let id = self.id();
    let timestamp = self.timestamp().map(|x| {
      x.unpack()
    });
    let quality = self.quality();
    VariableT {
      value,
      id,
      timestamp,
      quality,
    }
  }

  #[inline]
  pub fn value_type(&self) -> VariableValue {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VariableValue>(Variable::VT_VALUE_TYPE, Some(VariableValue::NONE)).unwrap()}
  }
  /// The value of the variable.
  #[inline]
  pub fn value(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Variable::VT_VALUE, None).unwrap()}
  }
  /// The ID of the variable associated with the provider's definition.
  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Variable::VT_ID, Some(0)).unwrap()}
  }
  /// The individual timestamp of the variable.
  ///
  /// Only set by the provider!
  /// Consumers can left this empty. This value is ignored by the provider in
  /// a write command.
  #[inline]
  pub fn timestamp(&self) -> Option<&'a Timestamp> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Timestamp>(Variable::VT_TIMESTAMP, None)}
  }
  /// The quality of the variable.
  ///
  /// Only set by the provider!
  /// Consumers can set it to BAD. This value is ignored by the provider
  /// in a write command.
  #[inline]
  pub fn quality(&self) -> VariableQuality {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VariableQuality>(Variable::VT_QUALITY, Some(VariableQuality::BAD)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_boolean(&self) -> Option<VariableValueBoolean<'a>> {
    if self.value_type() == VariableValue::Boolean {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueBoolean::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_duration(&self) -> Option<VariableValueDuration<'a>> {
    if self.value_type() == VariableValue::Duration {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueDuration::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_float_64(&self) -> Option<VariableValueFloat64<'a>> {
    if self.value_type() == VariableValue::Float64 {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueFloat64::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_int_64(&self) -> Option<VariableValueInt64<'a>> {
    if self.value_type() == VariableValue::Int64 {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueInt64::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_string(&self) -> Option<VariableValueString<'a>> {
    if self.value_type() == VariableValue::String {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueString::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_timestamp(&self) -> Option<VariableValueTimestamp<'a>> {
    if self.value_type() == VariableValue::Timestamp {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VariableValueTimestamp::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Variable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<VariableValue, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, true, |key, v, pos| {
        match key {
          VariableValue::Boolean => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueBoolean>>("VariableValue::Boolean", pos),
          VariableValue::Duration => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueDuration>>("VariableValue::Duration", pos),
          VariableValue::Float64 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueFloat64>>("VariableValue::Float64", pos),
          VariableValue::Int64 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueInt64>>("VariableValue::Int64", pos),
          VariableValue::String => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueString>>("VariableValue::String", pos),
          VariableValue::Timestamp => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableValueTimestamp>>("VariableValue::Timestamp", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<Timestamp>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<VariableQuality>("quality", Self::VT_QUALITY, false)?
     .finish();
    Ok(())
  }
}
pub struct VariableArgs<'a> {
    pub value_type: VariableValue,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub id: u32,
    pub timestamp: Option<&'a Timestamp>,
    pub quality: VariableQuality,
}
impl<'a> Default for VariableArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariableArgs {
      value_type: VariableValue::NONE,
      value: None, // required field
      id: 0,
      timestamp: None,
      quality: VariableQuality::BAD,
    }
  }
}

impl Serialize for Variable<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("Variable", 5)?;
      s.serialize_field("value_type", &self.value_type())?;
      match self.value_type() {
        VariableValue::NONE => (),
          VariableValue::Boolean => {
            let f = self.value_as_boolean()
              .expect("Invalid union table, expected `VariableValue::Boolean`.");
            s.serialize_field("value", &f)?;
          }
          VariableValue::Duration => {
            let f = self.value_as_duration()
              .expect("Invalid union table, expected `VariableValue::Duration`.");
            s.serialize_field("value", &f)?;
          }
          VariableValue::Float64 => {
            let f = self.value_as_float_64()
              .expect("Invalid union table, expected `VariableValue::Float64`.");
            s.serialize_field("value", &f)?;
          }
          VariableValue::Int64 => {
            let f = self.value_as_int_64()
              .expect("Invalid union table, expected `VariableValue::Int64`.");
            s.serialize_field("value", &f)?;
          }
          VariableValue::String => {
            let f = self.value_as_string()
              .expect("Invalid union table, expected `VariableValue::String`.");
            s.serialize_field("value", &f)?;
          }
          VariableValue::Timestamp => {
            let f = self.value_as_timestamp()
              .expect("Invalid union table, expected `VariableValue::Timestamp`.");
            s.serialize_field("value", &f)?;
          }
        _ => unimplemented!(),
      }
      s.serialize_field("id", &self.id())?;
      if let Some(f) = self.timestamp() {
        s.serialize_field("timestamp", &f)?;
      } else {
        s.skip_field("timestamp")?;
      }
      s.serialize_field("quality", &self.quality())?;
    s.end()
  }
}

pub struct VariableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VariableBuilder<'a, 'b> {
  #[inline]
  pub fn add_value_type(&mut self, value_type: VariableValue) {
    self.fbb_.push_slot::<VariableValue>(Variable::VT_VALUE_TYPE, value_type, VariableValue::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variable::VT_VALUE, value);
  }
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Variable::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: &Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(Variable::VT_TIMESTAMP, timestamp);
  }
  #[inline]
  pub fn add_quality(&mut self, quality: VariableQuality) {
    self.fbb_.push_slot::<VariableQuality>(Variable::VT_QUALITY, quality, VariableQuality::BAD);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VariableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VariableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Variable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Variable::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Variable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Variable");
      ds.field("value_type", &self.value_type());
      match self.value_type() {
        VariableValue::Boolean => {
          if let Some(x) = self.value_as_boolean() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        VariableValue::Duration => {
          if let Some(x) = self.value_as_duration() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        VariableValue::Float64 => {
          if let Some(x) = self.value_as_float_64() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        VariableValue::Int64 => {
          if let Some(x) = self.value_as_int_64() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        VariableValue::String => {
          if let Some(x) = self.value_as_string() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        VariableValue::Timestamp => {
          if let Some(x) = self.value_as_timestamp() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("value", &x)
        },
      };
      ds.field("id", &self.id());
      ds.field("timestamp", &self.timestamp());
      ds.field("quality", &self.quality());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VariableT {
  pub value: VariableValueT,
  pub id: u32,
  pub timestamp: Option<TimestampT>,
  pub quality: VariableQuality,
}
impl Default for VariableT {
  fn default() -> Self {
    Self {
      value: VariableValueT::NONE,
      id: 0,
      timestamp: None,
      quality: VariableQuality::BAD,
    }
  }
}
impl VariableT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Variable<'b>> {
    let value_type = self.value.variable_value_type();
    let value = self.value.pack(_fbb);
    let id = self.id;
    let timestamp_tmp = self.timestamp.as_ref().map(|x| x.pack());
    let timestamp = timestamp_tmp.as_ref();
    let quality = self.quality;
    Variable::create(_fbb, &VariableArgs{
      value_type,
      value,
      id,
      timestamp,
      quality,
    })
  }
}
